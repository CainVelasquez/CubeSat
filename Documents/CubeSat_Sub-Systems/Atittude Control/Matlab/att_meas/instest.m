%------------------------------------------------------------%
%                       instest.m
%
%   This function takes imu outputs generated by genIMUData.m or
%   genIMUData2.m and integrates them forward in time to get an 
%   attitude, position and velocity solution
%
%  Programmer:      Demoz Gebre-Egziabher
%  Last Modified:   20 October 2002
%  Created on:      October 16, 2001
%
%------------------------------------------------------------%

%==================================================================================%
% (a)                          Clear Up Work Space                                 %
%==================================================================================%

clear all;close all; clc;

%==================================================================================%
% (b)            Define Conversion Factors and Constants                           %
%==================================================================================%

d2r = pi/180;               %  Degrees to radians
r2d = 1/d2r;                %  Radians to degrees
ft2m = 0.3048;              %  Feet to meters
KTS2ms = 0.5144;            %  Knots to meters/sec
ms2KTS = 1/KTS2ms;          %  Meters/sec to Knots

omegaE = 7.292115e-5;       %  = 15.041 deg/hr.  Rotation Rate of Earth in Inertial Space
rE = 6378137;               %  Semi-major Axis of Earth (WGS-84)

cgo = 9.780373;             %  Constants for a simple gravity model (pp. 53 Titterton)
cg1 = 0.0052891;
cg2 = 0.0000059;

loadpath = 'D:\USERS\scratch\';   %'/home/gebre/inertial/m_files/simulated_data/';

%==================================================================================%
% (c)   Load IMU Data and Seclet Corrupted or Clean Sensor Outputs                 %
%                                                                                  %
%   (1) imu_xx = IMU (nx7). IMU = [t p q r ax ay az].  sec, rad/sec and m/sec/sec  %
%   (2) att = True Attitude History.  Euler angles in degrees                      %
%   (3) vel = True Velocity History.  NED Coordinates in Knots (i.e. nm/hr)        %
%   (4) pos_geo = True Position History.  Geodetic Coordinates.                    %
%   (5) pos_ned = True Position History.  NED Coordinates Centered at pos_geo(1,:) %
%                                                                                  %
%==================================================================================%

eval(['load ',loadpath,'uav_imu_data.mat']);
eval(['load ',loadpath,'uav_gps_data.mat']);

CORRUPTED_DATA = 0;

if(CORRUPTED_DATA)
    imu = imu_corrupt;
else
    imu = imu_good;
end

%==================================================================================%
% (d)   Parse Loaded Data and Define Place Holders                                 %
%                                                                                  %
%   (1) t = Time Vector in Seconds                                                 %
%   (2) drl = Data Record Length                                                   %
%   (3) eul =   Place Holder for INS Attitude Solution (euler angles in radians)   %
%   (4) pos_ins = Place Holder for INS Position Solution (Geodetic Coordinates)    %
%   (5) pos_ins_ned = Place Holder for pos_ins in NED centered at initial position %
%   (6) vel_ins = Place Holder for INS Velocity Solution (NED Coordinates)         %
%                                                                                  %
%==================================================================================%

t = imu(:,1);
drl = length(t);

eul = zeros(drl,3);
pos_ins = zeros(drl,3);
vel_ins = zeros(drl,3);

%==================================================================================%
% (e)                   Establish Initial Conditions                               %
%==================================================================================%

eul(1,:) = att(1,1:3);
quat(1,:) = eul2quat(eul(1,:)')';

pos_ins(1,:) = pos(1,1:3);
vel_ins(1,:) = vel(1,1:3);

pos_ref_ecef = lla2ecef([pos(1,1:2)';pos(1,3)]);    % Origin of NED Frame

vertical_surpression = 1;           %  If 1, the unstable INS vertical channel is damped
                                    %  by setting alt and vd equal to a constant

%==================================================================================%
% (f)                   Begin Main Computation Loop                                %
%                                                                                  %
%       While functions such as propagate.m can be used to perform the open loop   %
%       INS integration, we will not use these function here.  This is because     %
%       we want to show how the attitude, position and velocity histories are      %
%       computed.                                                                  %
%                                                                                  %
%==================================================================================%

wB = waitbar(0,'Generating INS Attitude, Velocity and Position Solution ...');

corbod = zeros(drl,3);

for k = 2:drl
    
    waitbar(k/drl,wB);                  %  Update Wait Bar
    
    %==================================================================================%
    %                    Constants for k-th Loop                                       %
    %==================================================================================%
    
    Ts = t(k)-t(k-1);                                   % Sampling Interval
    
    lat = pos_ins(k-1,1);                           % User's Latitude in Radians
    lon = pos_ins(k-1,2);                           % User's Longitude in Radians
    alt = pos_ins(k-1,3);                               % User's Altitude in Meters
    
    vn = vel_ins(k-1,1);                         % User's North-South Velocity in Meters/sec
    ve = vel_ins(k-1,2);                         % User's East-West Velocity in Meters/sec
    vd = vel_ins(k-1,3);                         % User's Up-Down Velocity in Meters/sec
    
    q = eul2quat(eul(k-1,:));                       % User's Attitude (quaternions)

    %==================================================================================%
    %                         Debugging Statements                                     %
    %==================================================================================% 
    
    if(0)                               % substitute true values for position
        lat = pos(k-1,1);
        lon = pos(k-1,2);
        alt = pos(k-1,3);
    end
    
    if(0)                               % substitute true values for velocity
        vn = vel(k-1,1);
        ve = vel(k-1,2);
        vd = vel(k-1,3);
    end
    
    if(0)                               % substitute true values for attitude
        q = eul2quat(att(k-1,:));
    end
   
    [Rew,Rns] = earthrad(lat);                          % Radii of Curvature of Earth
    
    earthRate = omegaE*[cos(lat);0;-sin(lat)];          % Earth Rate in NED Coordinates
    transRate = [   ve/(Rew - alt);....
                    -vn/(Rns - alt);...
                    -ve*tan(lat)/(Rew - alt)    ];      % Transport Rate in NED Coordinates
            
    totalRate = earthRate + transRate;                  % User's Measured Total rotation rate in NED Coordinates
    
    gLocal = [  0;...                                   % Local Gravitation Acceleration Vector
                0;...
                (cgo*(1+cg1*sin(lat)*sin(lat) - cg2*sin(2*lat)*sin(2*lat)))/...
                ((1+(alt/rE))*(1+(alt/rE)))];
        
    Cb2n = quat2dcm(q)';                                % Body to Navigation Frame Direction Cosine Matrix
 
    %==================================================================================%
    %                    Propagate Attitude Forward in Time                            %
    %==================================================================================%
    
    q = q/(q'*q);     % Normalize the Attitude Quaternion.  Very Important!

    %   Define two new vectors p and m (see research notes pp 24)

    p = Ts*(imu(k-1,2:4)' + totalRate);
    m = Ts*(imu(k-1,2:4)' - totalRate);

    %   Form the M matrix (see research notes pp 24)

    M = [0 -m';m -sk(p)];

    %   Integrate the quaternion differential equation and update quaternions

    q = expm(0.5*M)*q;                          % This is a simple Euler Integration
    eul(k,:) = dcm2eul(quat2dcm(q))';       % Convert Quaternions to Euler Angles 
    
    %==================================================================================%
    %                    Propagate Velocity Forward in Time                            %
    %==================================================================================%

    %   Compute the coriolis acceleration
    
    corAccel = sk(2*earthRate + transRate)*[vn;ve;vd];
    
    corbod(k,:) = ((Cb2n')*corAccel)';
    
    %   Compute Velocity Increment dv

    vDot = Cb2n*imu(k-1,5:7)' - (corAccel - gLocal);

    %   Update Velocity

    vel_ins(k,:) = ([vn;ve;vd] + Ts*vDot)';
 
    %==================================================================================%
    %                    Propagate Position Forward in Time                            %
    %==================================================================================%
    
    latRate = vn/(Rns - alt);
    lonRate = ve/((Rew - alt)*cos(lat));
    altRate = vd;
        
    %----> Define Some Temporary Position Variables to facilitate conversion to NED
    
    latTemp = lat + Ts*latRate; 
    lonTemp = lon + Ts*lonRate;
    altTemp = alt + Ts*altRate;
    
    pos_ecef = lla2ecef([latTemp;lonTemp;altTemp]);
    
    %----> Update Position Variables
    
    pos_ins(k,1) = (latTemp);
    pos_ins(k,2) = (lonTemp);
    pos_ins(k,3) = altTemp;

    %==================================================================================%
    %                 Check for Vertical Channel Surpression                           %
    %==================================================================================%

    if(vertical_surpression)
        vel_ins(k,3) = vel(k,3);
        pos_ins(k,3) = pos(k,3);
    end
    
end

close(wB);                          %  Close Wait Bar

%==================================================================================%
% (g)                          Plot the Results                                    %
%==================================================================================%

% Plot of Ground Track
 
figure(gcf);

plot(pos_ins(:,2)*r2d,pos_ins(:,1)*r2d,'r.');hold on;
plot(pos(:,2)*r2d,pos(:,1)*r2d,'b');grid on;
xlabel('Longitude (deg)');ylabel('Latitude (deg)');
axis('equal');

%  Plot Position History (Geodetic Coordinates)

figure(gcf+1)
subplot(121);
plot(t/60,pos(:,1),'b-');hold on;
plot(t/60, pos_ins(:,1),'r--');grid on;
xlabel('Time (min)');ylabel('Latitude (deg)');
legend('True (GPS) Position','INS Estimated Position');
title('Ship Position History');
subplot(122);
plot(t/60,pos(:,2),'b-');hold on;
plot(t/60, pos_ins(:,2),'r--');grid on;
xlabel('Time (min)');ylabel('Longitude (deg)');
legend('True (GPS) Position','INS Estimated Position');
title('Position in Geodetic Coordinates');

%  Plot Horizontal Velocity History

figure(gcf+1)
subplot(121);
plot(t/60,vel(:,1),'b-');hold on;
plot(t/60, vel_ins(:,1),'r--');grid on;
xlabel('Time (min)');ylabel('V_{NS} (Knots)');
legend('True (GPS) Velocity','INS Estimated Velocity');
title('Ship Horizontal Velocity');
subplot(122);
plot(t/60,vel(:,2),'b-');hold on;
plot(t/60, vel_ins(:,2),'r--');grid on;
xlabel('Time (min)');ylabel('V_{EW} (Knots)');
legend('True (GPS) Velocity','INS Estimated Velocity');
title('Velocity in NED Coordinates');

figure(gcf+1)

subplot(311)
plot(t/60,r2d*att(:,1),'b');hold on;
plot(t/60,r2d*eul(:,1),'r--');grid on;
ylabel('Heading (deg)');
legend('True (GPS) Attitude','INS Estimate History');

subplot(312)
plot(t/60,r2d*att(:,2),'b');hold on;
plot(t/60,r2d*eul(:,2),'r--');grid on;
ylabel('Pitch (deg)');

subplot(313)
plot(t/60,r2d*att(:,3),'b');hold on;
plot(t/60,r2d*eul(:,3),'r--');grid on;
ylabel('Roll (deg)');

xlabel('Time (min)');title('Ship Heading History.');


